{"version":3,"file":"vue-resizable-core.esm.js","sources":["../src/VueResizableCore.ts"],"sourcesContent":["import Vue, { CreateElement, PropType, VNode } from 'vue';\r\nimport { Axis, DragCallbackData, ResizeHandleAxis } from './types';\r\nimport { VueDraggableCore } from 'vue-draggable-core';\r\n\r\nexport default Vue.extend({\r\n    name: 'VueResizableCore',\r\n    props: {\r\n        width: {\r\n            type: Number,\r\n            default: 0\r\n        },\r\n        height: {\r\n            type: Number,\r\n            default: 0\r\n        },\r\n        draggableProps: {\r\n            type: Object,\r\n            default: undefined\r\n        },\r\n        handleSize: {\r\n            type: [Array, Object] as PropType<[number, number]>,\r\n            default: () => [20, 20]\r\n        },\r\n        lockAspectRatio: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        axis: {\r\n            type: String as PropType<Axis>,\r\n            default: 'both'\r\n        },\r\n        minConstraints: {\r\n            type: [Array, Object] as PropType<[number, number]>,\r\n            default: () => [20, 20]\r\n        },\r\n        maxConstraints: {\r\n            type: [Array, Object] as PropType<[number, number]>,\r\n            default: () => [Infinity, Infinity]\r\n        },\r\n        resizeHandles: {\r\n            type: Array as PropType<ResizeHandleAxis[]>,\r\n            default: ['se']\r\n        },\r\n        resizableHandleClass: {\r\n            type: [Object, String, Array],\r\n            default: 'vue-resizable-handle'\r\n        },\r\n        transformScale: {\r\n            type: Number,\r\n            default: 1\r\n        }\r\n    },\r\n    data() {\r\n        return {\r\n            lastHandleRect: null,\r\n            slack: null\r\n        };\r\n    },\r\n\r\n    beforeDestroy() {\r\n        this.resetData();\r\n    },\r\n    methods: {\r\n        lockAspectRatioFn(width: number, height: number, aspectRatio: number): [number, number] {\r\n            height = width / aspectRatio;\r\n            width = height * aspectRatio;\r\n            return [width, height];\r\n        },\r\n        resetData() {\r\n            this.lastHandleRect = this.slack = null;\r\n        },\r\n        // Clamp width and height within provided constraints\r\n        runConstraints(width: number, height: number): [number, number] {\r\n            const [min, max] = [this.minConstraints, this.maxConstraints];\r\n            if (!min && !max) return [width, height];\r\n\r\n            // If constraining to min and max, we need to also fit width and height to aspect ratio.\r\n            if (this.lockAspectRatio) {\r\n                const resizingHorizontally = height === this.height;\r\n                if (resizingHorizontally) {\r\n                    const ratio = this.width / this.height;\r\n                    height = width / ratio;\r\n                    width = height * ratio;\r\n                } else {\r\n                    // Take into account vertical resize with N/S handles on locked aspect\r\n                    // ratio. Calculate the change height-first, instead of width-first\r\n                    const ratio = this.height / this.width;\r\n                    width = height / ratio;\r\n                    height = width * ratio;\r\n                }\r\n            }\r\n\r\n            const [oldW, oldH] = [width, height];\r\n\r\n            // Add slack to the values used to calculate bound position. This will ensure that if\r\n            // we start removing slack, the element won't Vue to it right away until it's been\r\n            // completely removed.\r\n            let [slackW, slackH] = this.slack || [0, 0];\r\n            width += slackW;\r\n            height += slackH;\r\n\r\n            if (min) {\r\n                width = Math.max(min[0], width);\r\n                height = Math.max(min[1], height);\r\n            }\r\n            if (max) {\r\n                width = Math.min(max[0], width);\r\n                height = Math.min(max[1], height);\r\n            }\r\n\r\n            // If the width or height changed, we must have introduced some slack. Record it for the next iteration.\r\n            this.slack = [slackW + (oldW - width), slackH + (oldH - height)];\r\n\r\n            return [width, height];\r\n        },\r\n        /**\r\n         * Wrapper around drag events to provide more useful data.\r\n         *\r\n         * @param  {String} handlerName Handler name to wrap.\r\n         * @param axis\r\n         * @return {Function}           Handler function.\r\n         */\r\n        resizeHandler(handlerName: 'resize' | 'resizeStart' | 'resizeStop', axis: ResizeHandleAxis): Function {\r\n            return ({ node, deltaX, deltaY }: DragCallbackData, e: any) => {\r\n                // Reset data in case it was left over somehow (should not be possible)\r\n                if (handlerName === 'resizeStart') this.resetData();\r\n\r\n                // Axis restrictions\r\n                const canDragX = (this.axis === 'both' || this.axis === 'x') && axis !== 'n' && axis !== 's';\r\n                const canDragY = (this.axis === 'both' || this.axis === 'y') && axis !== 'e' && axis !== 'w';\r\n                // No dragging possible.\r\n                if (!canDragX && !canDragY) return;\r\n\r\n                // Decompose axis for later use\r\n                const axisV = axis[0];\r\n                const axisH = axis[axis.length - 1]; // intentionally not axis[1], so that this catches axis === 'w' for example\r\n\r\n                // Track the element being dragged to account for changes in position.\r\n                // If a handle's position is changed between callbacks, we need to factor this in to the next callback.\r\n                // Failure to do so will cause the element to \"skip\" when resized upwards or leftwards.\r\n                const handleRect = node.getBoundingClientRect();\r\n                if (this.lastHandleRect != null) {\r\n                    // If the handle has repositioned on either axis since last render,\r\n                    // we need to increase our callback values by this much.\r\n                    // Only checking 'n', 'w' since resizing by 's', 'w' won't affect the overall position on page,\r\n                    if (axisH === 'w') {\r\n                        const deltaLeftSinceLast = handleRect.left - this.lastHandleRect.left;\r\n                        deltaX += deltaLeftSinceLast;\r\n                    }\r\n                    if (axisV === 'n') {\r\n                        const deltaTopSinceLast = handleRect.top - this.lastHandleRect.top;\r\n                        deltaY += deltaTopSinceLast;\r\n                    }\r\n                }\r\n                // Storage of last rect so we know how much it has really moved.\r\n                this.lastHandleRect = handleRect;\r\n\r\n                // Reverse delta if using top or left drag handles.\r\n                if (axisH === 'w') deltaX = -deltaX;\r\n                if (axisV === 'n') deltaY = -deltaY;\r\n\r\n                // Update w/h by the deltas. Also factor in transformScale.\r\n                let width = this.width + (canDragX ? deltaX / this.transformScale : 0);\r\n                let height = this.height + (canDragY ? deltaY / this.transformScale : 0);\r\n\r\n                // Run user-provided constraints.\r\n                [width, height] = this.runConstraints(width, height);\r\n\r\n                const dimensionsChanged = width !== this.width || height !== this.height;\r\n\r\n                // Don't call 'onResize' if dimensions haven't changed.\r\n                const shouldSkipCb = handlerName === 'resize' && !dimensionsChanged;\r\n                if (!shouldSkipCb) {\r\n                    if (typeof e.persist === 'function') e.persist();\r\n                    this.$emit(handlerName, { node, size: { width, height }, handle: axis }, e);\r\n                }\r\n\r\n                // Reset internal data\r\n                if (handlerName === 'resizeStop') this.resetData();\r\n            };\r\n        },\r\n        children(h: CreateElement): VNode | VNode[] {\r\n            if (this.$scopedSlots.default) {\r\n                return this.$scopedSlots.default({\r\n                    resizeHandles: this.resizeHandles.map((handleAxis: ResizeHandleAxis) => ({\r\n                        axis: handleAxis,\r\n                        wrapper: VueDraggableCore,\r\n                        props: this.draggableProps,\r\n                        on: {\r\n                            dragStop: this.resizeHandler('resizeStop', handleAxis),\r\n                            dragStart: this.resizeHandler('resizeStart', handleAxis),\r\n                            drag: this.resizeHandler('resize', handleAxis)\r\n                        },\r\n                        class: `${this.resizableHandleClass} ${this.resizableHandleClass}-${handleAxis}`\r\n                    }))\r\n                });\r\n            }\r\n            return h('div');\r\n        }\r\n    },\r\n    render(h): VNode {\r\n        const children = this.children(h);\r\n        if (Array.isArray(children)) {\r\n            return children[0];\r\n        }\r\n        return children;\r\n    }\r\n});\r\n"],"names":["Vue","extend","name","props","width","type","Number","height","draggableProps","Object","undefined","handleSize","Array","lockAspectRatio","Boolean","axis","String","minConstraints","maxConstraints","Infinity","resizeHandles","resizableHandleClass","transformScale","data","lastHandleRect","slack","beforeDestroy","resetData","methods","lockAspectRatioFn","aspectRatio","runConstraints","min","max","resizingHorizontally","ratio","oldW","oldH","slackW","slackH","Math","resizeHandler","handlerName","e","node","deltaX","deltaY","canDragX","canDragY","axisV","axisH","length","handleRect","getBoundingClientRect","deltaLeftSinceLast","left","deltaTopSinceLast","top","dimensionsChanged","shouldSkipCb","persist","$emit","size","handle","children","h","$scopedSlots","map","handleAxis","wrapper","VueDraggableCore","on","dragStop","dragStart","drag","render","isArray"],"mappings":"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"}